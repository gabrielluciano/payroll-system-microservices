# Kubernetes Deployment

This folder contains Kubernetes resources YAML files for deploying a Kafka and microservices-based application on Kubernetes. So far it was tested on a single node cluster using microk8s distribution.

## Installation

Before proceeding with the installation, ensure that you have Microk8s installed on your Linux machine. You can install it using Snap:

```sh
sudo snap install microk8s --classic
```

### Step 1: Enable Microk8s Local Registry

This is necessary since we will push the docker images to the local registry. You can use some public registry if you want, just modify the image names.

```sh
microk8s enable registry
```

### Step 2: Enable Metallb Load Balancer

Metallb is a load balancer that can be used to expose services. During installation, you will be prompted to enter an IP range. Use the `hostname -I` or `ifconfig` commands to find the IP of your eth0 network interface, then select a range within this network.

```sh
microk8s enable metallb
```

### Step 3: Enable Helm

Helm is a package manager for Kubernetes. If Helm and Helm3 are not already enabled, enable them:

```sh
microk8s enable helm
microk8s enable helm3
```

### Step 4: Create Directories and Set Permissions

Create the directories that will hold kafka, prometheus and grafana data and set permissions. You probably don't need 777 permission for this, this is for demo purposes

```sh
sudo mkdir -p /data/kafka-data-0 /data/kafka-data-1 /data/kafka-data-2 /data/prometheus-data /data/grafana-data

sudo chmod -R 777 /data/kafka-data-0 /data/kafka-data-1 /data/kafka-data-2 /data/prometheus-data /data/grafana-data
```

### Step 5: Create Persistent Volumes

Create persistent volumes resources and verify them:

```sh
microk8s kubectl apply -f kubernetes/persistent-volumes
microk8s kubectl get pv
```

### Step 6: Deploying Kafka

To deploy Kafka, use the following command to install the Bitnami/Kafka Helm chart:

```sh
microk8s helm3 install kafka oci://registry-1.docker.io/bitnamicharts/kafka --version 30.1.8 -f kubernetes/helm/kafka-config.yaml 

## Verify if the pods are running
microk8s kubectl get pods
```

### Step 7: Create a Secret for Kafka Authentication

To create a secret for Kafka clients, follow these steps:

First, get the password generated by Bitnami/Kafka Helm chart using this command:

```sh
microk8s kubectl get secret kafka-user-passwords --namespace default -o jsonpath='{.data.client-passwords}' | base64 -d | cut -d , -f 1
```

This will output the password. Using this password, create a new secret called `kafka-security` with key `sasl-username` equals `user1` and key `sasl-password` equals the output of the previous command

```sh
microk8s kubectl create secret generic kafka-security --namespace default \
        --from-literal=sasl-username="user1" \
        --from-literal=sasl-password="<generated-password>"
```

### Step 8: Deploying NGINX Ingress Controller

To expose your application on the host machine, deploy the NGINX ingress controller using Helm:

```sh
microk8s helm3 install nginx-ingress oci://ghcr.io/nginxinc/charts/nginx-ingress --version 1.4.1
```

As we've installed MetalLB before, the nginx-ingress-controller service should have been assigned an external IP from the range we provided before. Verify its external IP address using the following command:

```sh
microk8s kubectl get svc nginx-ingress-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
```

### Step 9: Deploying ConfigMaps

Deploy configmaps for your application using the following commands:

```sh
microk8s kubectl apply -f kubernetes/configmaps
```

### Step 10: Deploying Secrets

Since there are many services, we need to create some secrets. These will mostly store database usernames and passwords. Make sure you use safe passwords!

```sh
# Create metrics security secret
microk8s kubectl create secret generic metrics-security --namespace default \
        --from-literal=username="service" \
        --from-literal=password="password"

# Create Keycloak admin panel secret
microk8s kubectl create secret generic keycloak-admin --namespace default \
        --from-literal=user="admin" \
        --from-literal=password="password"

# Create Keycloak database credentials secret
microk8s kubectl create secret generic keycloak-db --namespace default \
        --from-literal=user="admin" \
        --from-literal=password="password"

# Create employee service DB secret
microk8s kubectl create secret generic employee-service-db --namespace default \
        --from-literal=user="user" \
        --from-literal=password="password"

# Create inss-tax service DB secret
microk8s kubectl create secret generic inss-tax-service-db --namespace default \
        --from-literal=user="user" \
        --from-literal=password="password"

# Create income-tax service DB secret
microk8s kubectl create secret generic income-tax-service-db --namespace default \
        --from-literal=user="user" \
        --from-literal=password="password"

# Create payroll service DB secret
microk8s kubectl create secret generic payroll-service-db --namespace default \
        --from-literal=user="user" \
        --from-literal=password="password"

# Verify the secrets
microk8s kubectl get secret
```

*PRO Tip*: If you want to grep all secrets and keys from the kubernetes yaml files you can use this command:

```sh
tree -if kubernetes | xargs cat | grep -A 2 secretKeyRef | grep -E "name:|key:"
```

### Step 11: Deploying StatefulSets and Services

Deploy statefulsets for your application using the following command:

```sh
microk8s kubectl apply -f kubernetes/statefulsets

# Verify if all pods are in running status using microk8s kubectl get pods
```

### Step 12: Deploying Deployments

Before we create our deployments, we need to build and push the images to the local registry. Two scripts in the scripts directory helps us with this task

```sh
# Build images with tag 1.0
./scripts/docker-build-k8s.sh 1.0

# Push images with tag 1.0 for local registry
./scripts/docker-push-k8s.sh 1.0
```

After that, we are able to deploy our microservices under the kubernetes/deployments directories

```sh
microk8s kubectl apply -f kubernetes/deployments

# Verify if all pods are in running status using microk8s kubectl get pods
```

### Step 13: Exposing Deployments and Services

Expose deployments and services for your application using the following command:

```sh
microk8s kubectl apply -f kubernetes/services
```

### Step 14: Exposing API Gateway and Keycloak with ingress resources

Expose the API gateway and keycloak with an ingress resource using the following command:

```sh
microk8s kubectl apply -f kubernetes/ingress
```

### Step 15: Configuring the hostnames

If you look at the ingress resources, you will see that the api-gateway ingress is configured to use the `api` hostname and the keycloak resource, the `keycloak` hostname. Since we are in local development, to simulate a dns service, we can edit our hosts file to map these hostnames to the ip of the ingress.


1. Get the external IP address of the NGINX ingress controller:

```sh
microk8s kubectl get svc nginx-ingress-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
```

2. Edit the hosts file to map the `api` and `keycloak` hostnames to the external IP address:

```plaintext
# /etc/hosts
<EXTERNAL_IP> api
<EXTERNAL_IP> keycloak
```

After completing these steps, you can access your application using the api and keycloak hostnames.

